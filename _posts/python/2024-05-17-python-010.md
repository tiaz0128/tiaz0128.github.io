---
layout: post
date: 2024-10-19
catalogue: "python"
subject: "python"
title: "파이썬 쓰레드"
subtitle: "파이썬에서 쓰레드(Thread)와 락(Lock)에 대해 알아보겠습니다."
author: tiaz0128
permalink: /python/10
tags: [python, 쓰레드]
mermaid: true
---

## 프로그램(Program)

---

일반적으로 프로그램이란 하드 디스크(HDD), SSD 같은 디스크에 저장된 정적인 상태의 명령어 집합을 의미합니다. '정적인 상태'란 말은, 실행 중이지 않은 상태의 코드를 의미 합니다. 

<pre class="mermaid center">
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'lineColor': '#2196f3',
      'primaryTextColor': '#fff',
      'tertiaryColor': '#333'
    }
  }
}%%
flowchart LR
    subgraph "Hard Disk"
        Program[Program]
    end
</pre>

그렇다면 '실행 중'이라는 상태는 어떤 것을 의미 할까요? 프로그램이 실행되면 어떻게 되는지 알아봅시다.

## 프로세스(Process)

---

프로그램이 실행되면 독립된 메모리 공간을 할당받고 CPU가 명령어를 처리 할 수 있는 상태가 됩니다. 그리고 이런 상태를 '프로세스(Process)'라 합니다.

<pre class="mermaid center">
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'lineColor': '#2196f3',
      'primaryTextColor': '#fff',
      'tertiaryColor': '#333'
    }
  }
}%%
flowchart LR
    subgraph "Hard Disk"
        Program[Program]
    end

    subgraph "Memory"
        Process[Process]
    end

    Program --- Process
</pre>

### 여러개의 프로세스

같은 프로그램을 여러번 실행하여 프로세스는 여러개가 만들어 질 수 있습니다. 각각의 프로세스는 독립된 자원(메모리 등)을 가집니다. 노드패드를 여러개 실행한 상황을 생각해봅시다. *Notepad A*에 입력한 값이 다른 *Notepad B*에 전혀 영향을 주지않습니다.

<pre class="mermaid center">
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'lineColor': '#2196f3',
      'primaryTextColor': '#fff',
      'tertiaryColor': '#333'
    }
  }
}%%
flowchart LR
    subgraph "Hard Disk"
        Program[Program]
    end

    subgraph "Memory"
        Process1[Notepad A]
        Process2[Notepad B]
    end

    Program --- Process1
    Program --- Process2
</pre>

### 프로세스의 메모리 구성

프로세스는 메모리를 크게 4가지의 영역으로 나누어 사용합니다.

<pre class="mermaid center">
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'lineColor': '#2196f3',
      'primaryTextColor': '#000',
      'tertiaryColor': '#333'
    }
  }
}%%
flowchart TB
    subgraph "Memory"
        subgraph "Process"
            CS1[Code Section]
            DS1[Data Section]
            HS1[Heap Section]
            SS1[Stack Section]
        end
    end

    style Process fill:#555,stroke:#333,stroke-width:1px

    style CS1 fill:#bbf,stroke:#333,stroke-width:1px
    style DS1 fill:#ddf,stroke:#333,stroke-width:1px
    style HS1 fill:#ffd,stroke:#333,stroke-width:1px
    style SS1 fill:#dfd,stroke:#333,stroke-width:1px
</pre>

- 코드 영역(Code Section) : 실행 코드
- 데이터 영역(Data Section) : 전역 변수/정적 변수
- 힙 영역(Heap Section) : 동적 메모리 할당 영역
- 스택 영역(Stack Section) : 지역 변수, 함수 호출 정보

## 쓰레드(Thread)

---

프로세스는 메모리를 할당 받아 명령어를 실행할 수 있는 상태를 뜻했습니다. 그렇다면 프로세스에서 누가 명령어를 실행하는 걸까요? 바로 쓰레드(Thread)가 그 역할을 수행합니다.

> thread
> 1. 실 <br/>
> 2. (이야기 등의) 가닥[맥락] <br/>
> 3. (실 등을) 꿰다 <br/>

쓰레드는 프로세스 내에서 실행되는 작은 실행 단위를 의미합니다. 단어의 뜻처럼 "실행의 흐름" 또는 "제어의 흐름"라고 생각하면 됩니다. 그리고 프로세스는 최소 1개 이상의 쓰레드를 포함합니다.

<pre class="mermaid center">
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'lineColor': '#2196f3',
      'primaryTextColor': '#000',
      'tertiaryColor': '#333'
    }
  }
}%%
flowchart BT
    subgraph "Memory"
        subgraph "Process"
            T11[Thread 1]
            CODE1[code]
            CODE2[code]
        end
    end

    T11 --- CODE1
    CODE1 --- CODE2

    style Process fill:#555,stroke:#333,stroke-width:1px

    style T11 fill:#fff,stroke:#333,stroke-width:1px
    style CODE1 fill:#bbf,stroke:#333,stroke-width:1px
    style CODE2 fill:#bbf,stroke:#333,stroke-width:1px
</pre>

### 쓰레드의 자원 공유

하나의 프로세스 내에 두 개의 쓰레드가 있다고 가정해 봅시다. 각 쓰레드는 스택만 따로 할당받고 나머지 메모리 공간은 프로세스 내에서 공유하게 됩니다.

<pre class="mermaid center">
flowchart TB
    subgraph CPU["CPU"]
        Registers["레지스터"]
    end

    subgraph Process["Process"]
        subgraph Shared["공유 메모리 영역"]
            direction TB
            Code["Code 영역<br/>(프로그램 코드)"]
            Data["Data 영역<br/>(전역/Static 변수)"]
            Heap["Heap 영역<br/>(동적 할당 메모리)"]
        end

        subgraph ThreadStacks["쓰레드별 스택"]
            Stack1["Thread 1 Stack"]
            Stack2["Thread 2 Stack"]
        end
    end

    %% 스타일 정의
    style Process fill:#555,stroke:#333,stroke-width:1px,color:#bbb

    classDef cpu fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px
    classDef shared fill:#e1f5fe,stroke:#0288d1,stroke-width:2px
    classDef thread fill:#e8f5e9,stroke:#4caf50,stroke-width:2px
    classDef process fill:#f5f5f5,stroke:#333,stroke-width:2px

    class CPU cpu
    class Shared shared
    class ThreadContexts,ThreadStacks thread
    class Process process
</pre>

명령을 처리하는 CPU 코어 하나는 한 시점에 하나의 쓰레드만 실행 가능합니다. 때문에 여러 쓰레드가 동시에 실행하는 것처럼 보여도 사실은 여러 쓰레드를 번갈아가면서 빠르게 동작합니다.

### 컨텍스트 스위칭(context switching)

컨텍스트 스위칭(context switching)은 현재 실행 중인 프로세스/쓰레드를 중단하고 다른 프로세스/쓰레드를 실행하는 것을 뜻합니다. 이때마다 이전의 상태(컨텍스트)를 보관하고 새로운 상태로 전환하는 작업을 수행합니다.

![성능](/assets/img/content/python/010/001.png){:.img-s}

*> 출처 : [Akka in Action](https://livebook.manning.com/concept/akka/thread){:target="_blank"}*{:.img-caption}

쓰레드가 많아지면 처리도 빨라질까요? 정답일 수도 있고 아닐수도 있습니다. 왜냐하면 컨텍스트 스위칭도 하나의 작업이기 때문에, 너무 자주 발생하면 오버헤드가 발생 합니다. 따라서 적절한 균형을 맞추는 것이 중요합니다.

## 파이썬 쓰레드

---

파이썬에서는 기본적으로 하나의 프로세스에 하나의 쓰레드가 생성됩니다. 그리고 이 쓰레드를 메인 쓰레드(MainThread)라고 합니다. 메인 쓰레드에서 다른 쓰레드를 생성하고 사용하는 방법을 알아 보겠습니다.

<pre class="mermaid center">
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'lineColor': '#2196f3',
      'primaryTextColor': '#000',
      'tertiaryColor': '#333'
    }
  }
}%%
flowchart BT
    subgraph "Memory"
        subgraph "Process"
            T11[Main Thread]
            T12[Sub Thread]

            CODE1[code]
            CODE2[code]
        end
    end

    T11 --- CODE1
    T12 --- CODE2

    style Process fill:#555,stroke:#333,stroke-width:1px

    style T11 fill:#fff,stroke:#333,stroke-width:1px
    style T12 fill:#fff,stroke:#333,stroke-width:1px
    style CODE1 fill:#bbf,stroke:#333,stroke-width:1px
    style CODE2 fill:#bbf,stroke:#333,stroke-width:1px
</pre>

### threading.Thread

파이썬에서는 *threading.Thread* 내장 클래스를 통해 쓰레드를 만들 수 있습니다. `start` 메서드로 쓰레드를 실행 할 수 있습니다. `args` 인자값과 `kwargs` 인자값 중에서 반드시 하나만 사용해서 쓰레드에 인자값을 전달 해야 합니다.

- `target` : 쓰레드로 실행할 함수
- `args` : iterable 인자값 전달
- `kwargs` : dict 형태 인자값 전달

```python
import threading

thread = threading.Thread(target=lambda x: print(f"Hello, {x}"), args=("thread",))

thread.start()
```

```text
Hello, Thread
```

### threading.Thread 상속 클래스

Thread 클래스를 상속하여 쓰레드 클래스를 정의 할 수 있습니다. `target` 인자값을 사용하는 대신, `run` 메서드를 오버라이드하여 쓰레드가 실행할 작업 정의합니다.

```python
import threading

class MyThread(threading.Thread):
    def __init__(self, name):
        super().__init__()        
        self.name = name
        
    def run(self):
        print(f"Hello, {self.name}")

thread = MyThread("MyThread")
thread.start()
```

### 현재 쓰레드 정보

`current_thread` 메서드를 통해 현재 쓰레드의 정보를 확인 할 수 있습니다.

- `ident` : 쓰레드 고유 식별자
- `name` : Thread-숫자 (함수 명). 메인 쓰레드의 경우 = MainThread

```python
import threading as th

def sub_thread():
    print(f"{th.current_thread().name} : {th.current_thread().ident}")

thread1 = th.Thread(target=sub_thread)
thread2 = th.Thread(target=sub_thread)

if __name__ == "__main__":
    thread1.start()
    thread2.start()

    print(f"{th.current_thread().name} Done")
```

```text
Thread-1 (sub_thread) : 139696827188800
Thread-2 (sub_thread) : 140045886248512
MainThread Done
```

## 쓰레드 join과 daemon

---

`join` 메서드에 대해서 알아봅시다.

```python
import threading as th

def print_numbers(i: int):
    for j in range(1, i + 1):
        print(f"Sub Thread : {j}")

thread1 = th.Thread(target=print_numbers, args=(100,))

if __name__ == "__main__":
    thread1.start()
    print(f"{th.current_thread().name} Done")
```

```text
Sub Thread : 6
Sub Thread : 7
...
MainThread Done
...
Sub Thread: 100
```
