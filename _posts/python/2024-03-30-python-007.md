---
layout: post
date: 2024-03-30
catalogue: "python"
subject: "python"
title: "디자인 패턴 - 팩토리(Factory) 심화"
excerpt: "메서드 팩토리(Method Factory), 추상 팩토리(Abstract Factory)에 대해서 알아보겠습니다."
author: tiaz
permalink: /python/7
tags: [python, 디자인패턴, 팩토리]
mermaid: true
---

<div class="callout">:memo:
  <div>
    <span>이전편 - </span>
    <a href="/python/6" target="_blank">
        <strong>디자인 패턴 - 팩토리(Factory) 기본 개념</strong>
    </a>
  </div>
</div>

## 팩토리 패턴의 종류

---

앞서 본 패턴은 가장 기본적인 구조로 `SimpleFactory` 패턴이라고 합니다. 이번에는 나머지 두가지 패턴에 대해서 알아보도록 하겠습니다.

1. `SimpleFactory`
2. `MethodFactory`
3. `AbstractFactory`

## 메서드 팩토리 패턴(Method Factory)

---

객체 생성 로직을 서브클래스로 캡슐화하여 유연성과 확장성을 제공합니다. 객체 생성을 위한 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지는 서브클래스가 결정하도록 합니다.

### 상황

피자 가게가 너무너무 잘됐습니다. 각 도시마다 지점을 낸다고 생각해 보겠습니다. 그리고 각 지점은 같은 메뉴라도, 해당 지역의 특색이 감미되게 공장에서 재료를 가공해서 배달합니다.

![src](/assets/img/content/python/007/001.png){:.img-s}

### 코드

우선은 각 지역의 피자를 만들어 두겠습니다. 그리고 피자 분기문에 사용할 `enum` 타입을 하나 만들어 두겠습니다.

```python
from abc import ABC

class Pizza(ABC):
    name = "피자"

class NYStyleCheesePizza(Pizza):
    name = "뉴욕 치즈 핏자"

class ChicagoStyleCheesePizza(Pizza):
    name = "시카고 치즈 핏자"
```

```python
from enum import StrEnum

class PizzaType(StrEnum):
    CHEESE = "cheese"
```

---

이제 가장 중요한 팩토리 클래스를 작성하겠습니다. 이 패턴의 가장 핵심은 인터페이스에서 객체 생성 메서드를 선언하고, *하위 클래스가 이 메서드를 구현하는 것입니다.*{:.yellow}

즉 여러개의 팩토리 클래스가 만들어 질 수 있고, 각 팩토리 클래스마다 원하는 구현을 추가 할 수 있다는 장점이 있습니다.

```python
from abc import ABC, abstractmethod
from typing import override


class MethodFactory(ABC):
    @abstractmethod
    def create_pizza(self, pizza_type):
        pass

class NYPizzaFactory(MethodFactory):
    @override
    def create_pizza(self, pizza_type):
        match pizza_type:
            case PizzaType.CHEESE:
                return NYStyleCheesePizza()

class ChicagoPizzaFactory(MethodFactory):
    @override
    def create_pizza(self, pizza_type):
        self.cut_rectangle()

        match pizza_type:
            case PizzaType.CHEESE:
                return ChicagoStyleCheesePizza()

    def cut_rectangle(self):
        print("시카고 피자는 모양이 네모납니다.")
```

---

이제 팩토리 객체를 사용하는 클라이언트는 객체 주입을 통해 각 상황에 알맞은 팩토리 객체를 받아서 사용하면 됩니다. 뉴욕 지점을 만들고 싶다면 뉴욕 팩토리를 받아서 피자를 만들고, 시카고 지점을 만들고 싶으면 시카고 팩토리를 넣어주면 되는거죠.

```python
class PizzaStore:
    def __init__(self, factory: MethodFactory) -> None:
        self.factory = factory

    def order(self, pizza_type: PizzaType) -> Pizza:
        pizza = self.factory.create_pizza(pizza_type)
        return pizza
```

```python
if __name__ == "__main__":
    ny_factor = NYPizzaFactory()
    ny_store = PizzaStore(ny_factor)
    ny_store.order(PizzaType.CHEESE)

    ch_factory = ChicagoPizzaFactory()
    ch_store = PizzaStore(ch_factory)
    ch_store.order(PizzaType.CHEESE)
```

같은 치즈 피자라도 각 팩토리를 통해서 다양한 특색을 갖게 만들 수 있습니다.

```bash
뉴욕 치즈 핏자를 주문하셨습니다.

시카고 피자는 모양이 네모납니다.
시카고 치즈 핏자를 주문하셨습니다.
```

### 클래스 다이어그램 : MethodFactory

<pre class="mermaid center">
%%{
  init: {
    'theme': 'default',
    'themeVariables': {
      'lineColor': '#F8B229',
      'tertiaryColor': '#fff'
    }
  }
}%%
classDiagram
    class PizzaStore{
        -MethodFactory factory
        +order() Pizza
    }

    class MethodFactory {
        &lt;&lt;abstract&gt;&gt;
        +createPizza(type) Pizza
    }

    class NYPizzaFactory {
        +createPizza(type) Pizza
    }

    class ChicagoPizzaFactory {
        +createPizza(type) Pizza
        +cut_rectangle()
    }

    PizzaStore --o MethodFactory
    MethodFactory <|-- NYPizzaFactory
    MethodFactory <|-- ChicagoPizzaFactory

    class Pizza {
        &lt;&lt;abstract&gt;&gt;
        str name
    }

    class NYStyleCheesePizza {
        str name
    }

    class ChicagoStyleCheesePizza {
        str name
    }

    NYStyleCheesePizza ..|> Pizza
    ChicagoStyleCheesePizza ..|> Pizza

    NYPizzaFactory --* NYStyleCheesePizza
    ChicagoPizzaFactory --* ChicagoStyleCheesePizza
</pre>

## 추상 팩토리(Abstract Factory)

---

군집

```python

```
