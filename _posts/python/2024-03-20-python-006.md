---
layout: post
date: 2024-03-20
catalogue: "python"
subject: "python"
title: "디자인 패턴 - 팩토리(Factory) 기본 개념"
excerpt: "파이썬에서 팩토리(Factory) 기본 개념을 정리합니다."
author: tiaz
permalink: /python/6
tags: [python, 디자인패턴]
---

## 팩토리(Factory)

---

팩토리 패턴은 객체 생성을 위한 디자인 패턴 중 하나입니다. 이 패턴의 주요 목적은 **객체 생성 로직을 클라이언트 코드로부터 분리**하는 것입니다.

![factory](/assets/img/content/python/006/001.png){:.img-s}

피자를 만드는 가게를 운영한다고 생각하고 팩토리 패턴 대해 알아봅시다!

## step 1. 치즈만 만드는 피자 가게

---

### 상황

치즈 피자만 만드는 가게를 오픈했습니다. 들어오는 주문은 한 종류, _'치즈 피자'_ 만 만들면 됩니다.

![src](/assets/img/content/python/006/002.png){:.img-s}

### 코드

주문에 들어오는 피자 종류는 한가지 뿐이니, 고민할 필요도 없이 치즈 피자만 만들면 됩니다.

```python
from enum import StrEnum

class PizzaType(StrEnum):
    CHEESE = 'cheese pizza'
```

```python
class PizzStore:
    def order(self, pizza_type: PizzaType):
        pizza = CheesePizza()
        pizza.package()
```

## step 2. 피자 종류를 늘리자!

---

### 상황

장사가 잘되서 기쁜 마음으로 피자 종류를 다양하게 늘렸습니다.

> "왜 이렇게 자꾸 장사가 잘되는데?!"

![src](/assets/img/content/python/006/003.png){:.img-s}

들어오는 주문에 따라 수많은 종류의 피자를 만들어야 합니다. 피자 종류가 많아질수록 점점 더 힘들어 집니다. 메뉴가 많다보니 많이 안 팔리는 메뉴는 또 빼야만 할것 같습니다.

### 코드

이제 주문에 들어오는 피자 종류에 따라서 각각의 피자를 만들어야 합니다. 그래서 분기문을 추가 합니다. 하지만 피자 종류를 추가할때 마다 점점 더 많은 분기문이 필요해집니다.

```python
from enum import StrEnum

class PizzaType(StrEnum):
    CHEESE = 'cheese pizza'
    CLAM = 'clam pizza' # 추가
    HAM = 'ham pizza'   # 추가
```

```python
class PizzStore:
    def order(self, pizza_type: PizzaType):
        match pizza_type:
            case pizza_type.CHEESE:
                pizza = CheesePizza()
            case pizza_type.CLAM:
                pizza = ClamPizza()
            case pizza_type.HAM:
                pizza = HamPizza()
            #
            # 점점 많아지는 분기문...
            #

        pizza.package()
```

## step 3. 공장에서 만들어진 피자를 받자

---

### 상황

이제 직접 수많은 종류의 피자를 직접 만들지 않기로 합니다. 공장에서 만들어진 피자를 받아서 팔기로 했습니다. 공장에서 피자를 받아오니 다양한 피자를 만들기 위해 복잡했던 가게가 깔금하게 정리됐습니다!

![src](/assets/img/content/python/006/004.png){:.img-s}

### 코드

여러가지 피자를 만들려다 보니 피자 가게 클래스가 복잡했습니다. 이걸 피자만 만드는 팩토리 객체를 통해서 피자를 받아오게 변경합니다.

```python
from enum import StrEnum

class PizzaType(StrEnum):
    CHEESE = 'cheese pizza'
    CLAM = 'clam pizza'
    HAM = 'ham pizza'
```

```python
class PizzStore:
    def __init__(self):
        self.factory = PizzaFactory()

    def order(self, pizza_type: PizzaType):
        pizza = self.factory.make(pizza_type) # 깔금해진 가게

        pizza.package()
```

```python
class PizzFactory:
    def make(self, pizza_type: PizzaType):
        match pizza_type:
            case pizza_type.CHEESE:
                pizza = CheesePizza()
            case pizza_type.CLAM:
                pizza = ClamPizza()
            case pizza_type.HAM:
                pizza = HamPizza()

        return pizza
```

## 장점이 뭐야?

---

팩토리 클래스를 작성해 보면 이런 생각이 듭니다.

> 복잡한 문제를 그냥 다른 객체로 넘긴게 아니야?

물론 그렇게 보일 수 있습니다. 지금까지는 팩토리 객체를 사용하는 객체가 하나라고만 생각했기 때문일 수 있습니다. 좀더 확장해서 생각해 봅시다. 팩토리 객체를 사용하는 다른 객체가 많아지면 어떨까요?

```python
class PizzFactory:
    def make(self, pizza_type: PizzaType):
        match pizza_type:
            case pizza_type.CHEESE:
                pizza = CheesePizza()
            case pizza_type.CLAM:
                pizza = ClamPizza()
            case pizza_type.HAM:
                pizza = HamPizza()

            # 푸드트럭에서만 파는 메뉴
            case pizza_type.MINI_CHEESE:
                pizza = MiniHamPizza()
            case pizza_type.MINI_CLAM:
                pizza = MiniHamPizza()
            case pizza_type.MINI_HAM:
                pizza = MiniHamPizza()

        return pizza
```

```python
class PizzStore:
    def __init__(self):
        self.factory = PizzaFactory()

    def order(self, pizza_type: PizzaType):
        pizza = self.factory.make(pizza_type) # 가게에서도

        pizza.package()
```

```python
class PizzFoodTruck:
    def __init__(self):
        self.factory = PizzaFactory()

    def order(self, pizza_type: PizzaType):
        pizza = self.factory.make(pizza_type) # 푸드트럭에서도 

        pizza.package()
```

`PizzStore`와 `PizzFoodTruck` 어디에서도 피자에 대한 흔적을 찾아 볼 수 없습니다. 

이처럼 팩토리 패턴을 통해서 피자 자체에 대한 의존성을 제거 할 수 있습니다. 복잡하게 생성해야 하는 각 피자 객체를 하나의 팩토리 객체를 통해 해결 할 수 있게 됐습니다!

## 결론

---


